<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>新开户尽职调查表 · 智能生成器</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;600;700&family=Noto+Serif+SC:wght@600;700&display=swap" rel="stylesheet" />
  <style>
    :root{
      --bg1:#eef6ef;
      --bg2:#e3efe8;
      --paper:rgba(255,255,255,.94);
      --ink:#1b2a22;
      --muted:#5e6e63;
      --line:#d7e5db;
      --accent1:#1f4d3a;
      --accent2:#3f7a5c;
      --accent3:#8bb99a;
      --radius:22px;
      --shadow:0 22px 60px rgba(20,38,28,.16);
      --font-body:'Noto Sans SC','Source Han Sans SC','PingFang SC','Hiragino Sans GB','Microsoft Yahei',sans-serif;
      --font-display:'Noto Serif SC','Source Han Serif SC','STSong','Songti SC',serif;
    }
    *{box-sizing:border-box;font-family:var(--font-body)}
    body{
      margin:0;
      min-height:100vh;
      background:
        radial-gradient(900px 500px at -10% 10%,rgba(63,122,92,.2),transparent 60%),
        radial-gradient(700px 400px at 100% 0%,rgba(139,185,154,.22),transparent 55%),
        linear-gradient(180deg,var(--bg1) 0%,var(--bg2) 65%,#f6fbf7 100%);
      color:var(--ink);
      padding-bottom:calc(140px + env(safe-area-inset-bottom));
    }
    body::after{
      content:'';
      position:fixed;
      inset:0;
      pointer-events:none;
      background:
        radial-gradient(280px 180px at 80% 20%,rgba(139,185,154,.2),transparent 70%),
        radial-gradient(240px 200px at 10% 70%,rgba(63,122,92,.16),transparent 70%);
      mix-blend-mode:multiply;
      opacity:.7;
    }
    .shell{
      max-width:960px;
      margin:0 auto;
      padding:32px clamp(16px,4vw,40px) 80px;
      padding-top:calc(32px + env(safe-area-inset-top));
      padding-left:calc(clamp(16px,4vw,40px) + env(safe-area-inset-left));
      padding-right:calc(clamp(16px,4vw,40px) + env(safe-area-inset-right));
    }
    header.hero{display:flex;gap:18px;align-items:center;margin-bottom:26px;flex-wrap:wrap;animation:rise .7s cubic-bezier(.16,1,.3,1) both}
    .logo{width:66px;height:66px;border-radius:22px;background:conic-gradient(from 160deg,var(--accent1),#2f6a4d 35%,var(--accent3) 55%,var(--accent2) 78%,var(--accent1));box-shadow:0 18px 34px rgba(31,77,58,.28)}
    h1{margin:0;font-family:var(--font-display);font-size:clamp(22px,5vw,34px);font-weight:700;letter-spacing:.4px}
    .hero p{margin:8px 0 0;font-size:14px;color:var(--muted)}
    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:18px}
    .card{
      background:linear-gradient(160deg,rgba(255,255,255,.7),rgba(255,255,255,.52));
      border-radius:var(--radius);
      border:1px solid rgba(255,255,255,.55);
      box-shadow:0 24px 60px rgba(21,42,32,.18), inset 0 1px 0 rgba(255,255,255,.5);
      padding:24px;
      backdrop-filter:saturate(160%) blur(18px);
      -webkit-backdrop-filter:saturate(160%) blur(18px);
      position:relative;
      overflow:hidden;
    }
    .card::before{content:'';position:absolute;inset:0 0 auto 0;height:4px;background:linear-gradient(90deg,var(--accent1),var(--accent3),var(--accent2));opacity:.65}
    .card::after{
      content:'';
      position:absolute;
      inset:-40% -10% auto -10%;
      height:120%;
      background:linear-gradient(120deg,rgba(255,255,255,.35),transparent 55%);
      opacity:.35;
      pointer-events:none;
    }
    .card h2{margin:0 0 14px;font-size:18px;color:#2b262f;display:flex;align-items:center;gap:8px}
    .card h2::after{content:'';flex:1;height:2px;background:linear-gradient(90deg,rgba(63,122,92,.3),transparent)}
    label{display:block;font-size:14px;font-weight:600;color:#4c4653;margin-bottom:6px}
    input[type=text],input[type=file]{width:100%;border:1px solid var(--line);border-radius:14px;padding:13px 15px;font-size:15px;color:var(--ink);background:rgba(255,255,255,.95);outline:none;transition:border .2s,box-shadow .2s,transform .2s}
    input[type=text]:focus,input[type=file]:focus{border-color:rgba(63,122,92,.6);box-shadow:0 0 0 4px rgba(63,122,92,.2);transform:translateY(-1px)}
    .field{margin-bottom:18px}
    .hint{font-size:13px;color:var(--muted);margin-top:6px}
    .photos{display:flex;flex-direction:column;gap:14px}
    .preview{display:grid;grid-template-columns:repeat(auto-fill,minmax(130px,1fr));gap:12px}
    .thumb{width:100%;aspect-ratio:4/3;border-radius:14px;border:1px dashed rgba(63,122,92,.45);object-fit:cover;box-shadow:0 12px 26px rgba(23,40,30,.1)}
    .dock{
      position:fixed;
      left:0;
      right:0;
      bottom:0;
      background:rgba(244,250,246,.7);
      border-top:1px solid rgba(255,255,255,.65);
      box-shadow:0 -16px 36px rgba(18,36,26,.16);
      backdrop-filter:saturate(160%) blur(20px);
      -webkit-backdrop-filter:saturate(160%) blur(20px);
      padding-bottom:env(safe-area-inset-bottom);
    }
    .dock::before{
      content:'';
      position:absolute;
      inset:0 0 auto 0;
      height:1px;
      background:linear-gradient(90deg,transparent,rgba(255,255,255,.8),transparent);
      opacity:.8;
    }
    .dock-inner{
      max-width:960px;
      margin:0 auto;
      padding:16px clamp(16px,4vw,34px);
      padding-bottom:calc(16px + env(safe-area-inset-bottom));
      padding-left:calc(clamp(16px,4vw,34px) + env(safe-area-inset-left));
      padding-right:calc(clamp(16px,4vw,34px) + env(safe-area-inset-right));
      display:flex;
      gap:14px;
      align-items:center;
    }
    .btn{flex:1;border:none;border-radius:18px;padding:16px 20px;font-size:16px;font-weight:600;color:#fff;background:linear-gradient(110deg,var(--accent1),#2f6a4d 40%,var(--accent3) 70%,var(--accent2));box-shadow:0 18px 36px rgba(31,77,58,.25);cursor:pointer;transition:transform .18s,box-shadow .18s,filter .18s}
    .btn:hover{filter:brightness(1.02)}
    .btn:active{transform:translateY(1px);box-shadow:0 8px 20px rgba(31,77,58,.25)}
    .status{font-size:13px;color:var(--muted)}
    .reveal{animation:rise .7s cubic-bezier(.16,1,.3,1) both;animation-delay:var(--d,0ms)}
    @keyframes rise{
      from{opacity:0;transform:translateY(16px)}
      to{opacity:1;transform:translateY(0)}
    }
    @media (max-width:720px){
      header.hero{flex-direction:column;align-items:flex-start}
      .grid{grid-template-columns:1fr}
      .dock-inner{flex-direction:column;align-items:stretch}
      .btn{width:100%}
    }
  </style>
</head>
<body>
  <div class="shell">
    <header class="hero">
      <div class="logo" aria-hidden="true"></div>
      <div>
        <h1>新开户尽职调查表 · 智能生成器</h1>
        <p>本地运行 · 三项信息 + 走访照片，即可生成符合模板的 DOCX</p>
      </div>
    </header>

    <div class="grid">
      <section class="card reveal" style="--d:40ms">
        <h2>① 客户信息</h2>
        <div class="field">
          <label for="customer">客户名称</label>
          <input id="customer" type="text" placeholder="如：厦门星辰创意有限公司" />
        </div>
        <div class="field">
          <label for="industry">行业分类</label>
          <input id="industry" type="text" placeholder="如：L7241 会计、审计及税务服务" />
        </div>
        <div class="field">
          <label for="address">经营地址</label>
          <input id="address" type="text" placeholder="如：厦门市湖里区高林中一路 188 号" />
        </div>
        <div class="hint">仅这三项必填，其余复选框默认留空。</div>
      </section>

      <section class="card reveal" style="--d:120ms">
        <h2>② 模板文件</h2>
        <label for="tpl">导入《新开户尽职调查表模版.docx》</label>
        <input id="tpl" type="file" accept=".docx" />
        <div class="hint">模板只需导入一次，可随时重新选择最新版。</div>
      </section>
    </div>

    <section class="card reveal" style="margin-top:20px;--d:200ms">
      <h2>③ 上门核实照片</h2>
      <div class="photos">
        <input id="photos" type="file" accept="image/*" multiple />
        <div class="hint">系统会自动按 2 张/页排版，并缩放到统一尺寸。</div>
        <div class="preview" id="preview"></div>
      </div>
    </section>
  </div>

  <div class="dock">
    <div class="dock-inner">
      <button class="btn" id="btnGen">生成 DOCX</button>
      <div class="status" id="status">等待生成…</div>
    </div>
  </div>

  <script>
  'use strict';
  const statusEl = document.getElementById('status');
  function setStatus(msg){ if(statusEl) statusEl.textContent = msg; }

  async function ensurePizZip(){
    if(window.PizZip){ return; }
    const sources = [
      'https://cdn.jsdelivr.net/npm/pizzip@3.1.7/dist/pizzip.min.js',
      'https://unpkg.com/pizzip@3.1.7/dist/pizzip.min.js'
    ];
    for(const url of sources){
      try{
        await new Promise((resolve,reject)=>{
          const script=document.createElement('script');
          script.src=url;
          script.onload=resolve;
          script.onerror=reject;
          document.head.appendChild(script);
        });
        if(window.PizZip){ return; }
      }catch(err){ console.warn('PizZip 加载失败，尝试下一个源', err); }
    }
    throw new Error('无法加载 PizZip，请联网后刷新页面。');
  }

  const W_NS = 'http://schemas.openxmlformats.org/wordprocessingml/2006/main';
  const PLACEHOLDERS = ['客户名称','行业分类','经营地址'];
  const PHOTO_TOKEN = '[[PHOTO]]';

  const tplInput = document.getElementById('tpl');
  let tplBuffer = null;
  if(tplInput){
    tplInput.addEventListener('change', async (e)=>{
      const file = e.target.files[0];
      if(!file){ tplBuffer=null; setStatus('尚未导入模板'); return; }
      try{
        tplBuffer = await file.arrayBuffer();
        setStatus('已缓存模板：'+file.name);
      }catch(err){
        tplBuffer = null;
        setStatus('模板读取失败');
        alert('无法读取模板：'+err.message);
      }
    });
  }

  const photoInput = document.getElementById('photos');
  const previewBox = document.getElementById('preview');
  let selectedPhotos = [];
  if(photoInput){
    photoInput.addEventListener('change',(e)=>{
      selectedPhotos = Array.from(e.target.files || []);
      if(previewBox){
        previewBox.innerHTML = '';
        selectedPhotos.forEach((file)=>{
          const url = URL.createObjectURL(file);
          const img = document.createElement('img');
          img.className = 'thumb';
          img.src = url;
          img.onload = ()=>URL.revokeObjectURL(url);
          previewBox.appendChild(img);
        });
      }
      setStatus(selectedPhotos.length ? `已选择 ${selectedPhotos.length} 张照片` : '未添加照片');
    });
  }

  function ensurePhotoBlock(xml){
    const block = `<w:p><w:r><w:t>${PHOTO_TOKEN}</w:t></w:r></w:p>`;
    const marker = /(<w:p[^>]*>[\s\S]*?上门核实图片[\s\S]*?<\/w:p>)/;
    if(marker.test(xml)) return xml.replace(marker,'$1'+block);
    const bodyClose = /<\/w:body>\s*<\/w:document>/;
    if(bodyClose.test(xml)) return xml.replace(bodyClose, block+'</w:body></w:document>');
    return xml + block;
  }

  function escapeRegExp(text){
    return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  function sanitizeFileName(name){
    return (name || '未命名').replace(/[\\/:*?"<>|]/g,'_');
  }

  function replacePlaceholdersXML(xml,map){
    const parser = new DOMParser();
    const dom = parser.parseFromString(xml,'application/xml');
    if(dom.getElementsByTagName('parsererror').length){
      throw new Error('模板解析失败，请确认 DOCX 正常。');
    }
    const stats = {};
    const regexes = {};
    Object.keys(map).forEach((key)=>{
      stats[key] = 0;
      regexes[key] = new RegExp('{{\\s*'+key+'\\s*}}','g');
    });
    Array.from(dom.getElementsByTagNameNS(W_NS,'p')).forEach((p)=>{
      const texts = Array.from(p.getElementsByTagNameNS(W_NS,'t'));
      if(!texts.length) return;
      let joined = texts.map((t)=>t.textContent || '').join('');
      let changed = false;
      Object.keys(map).forEach((key)=>{
        const regex = regexes[key];
        const matches = joined.match(regex);
        if(matches){
          stats[key]+=matches.length;
          joined = joined.replace(regex, map[key]);
          changed = true;
        }
      });
      if(changed){
        texts[0].textContent = joined;
        for(let i=1;i<texts.length;i++){
          const run = texts[i].parentNode;
          texts[i].parentNode.removeChild(texts[i]);
          if(run && !run.textContent){
            run.parentNode && run.parentNode.removeChild(run);
          }
        }
      }
    });
    const serializer = new XMLSerializer();
    return { xml: serializer.serializeToString(dom), stats };
  }

  function inchToEmu(inches){ return Math.round(inches * 914400); }
  function nextMedia(zip){
    const files = Object.keys(zip.files).filter((k)=>k.indexOf('word/media/')===0);
    const nums = files.map((f)=>{
      const m = f.match(/image(\d+)\./);
      return m ? parseInt(m[1],10) : 0;
    });
    const next = nums.length ? Math.max.apply(null, nums)+1 : 1;
    return 'word/media/image'+next+'.jpeg';
  }
  function nextRid(rels){
    const ids=[]; const re=/Id="rId(\d+)"/g; let m;
    while((m=re.exec(rels))){ ids.push(parseInt(m[1],10)); }
    const max = ids.length ? Math.max.apply(null, ids) : 800;
    return 'rId'+(max+1);
  }

  function ensureImageContentTypes(zip){
    const ctPath='[Content_Types].xml';
    const ctFile=zip.file(ctPath);
    if(!ctFile) return;
    let xml=ctFile.asText();
    const defaults=[
      { ext:'jpeg', type:'image/jpeg' },
      { ext:'jpg', type:'image/jpeg' },
      { ext:'png', type:'image/png' }
    ];
    let insert='';
    defaults.forEach((item)=>{
      const re=new RegExp(`Extension="${item.ext}"`,'i');
      if(!re.test(xml)) insert+=`<Default Extension="${item.ext}" ContentType="${item.type}"/>`;
    });
    if(insert){
      xml=xml.replace('</Types>', insert+'</Types>');
      zip.file(ctPath, xml);
    }
  }

  function addImageRelationship(zip, rels, base64){
    const media = nextMedia(zip);
    zip.file(media, base64, { base64:true });
    const rid = nextRid(rels);
    const updated = rels.replace('</Relationships>',`\n  <Relationship Id="${rid}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/image" Target="${media.replace('word/','')}"/>\n</Relationships>`);
    return { rid, rels: updated };
  }

  function buildDrawingXml(rid, widthIn, heightIn, docPrId){
    const w = inchToEmu(widthIn);
    const h = inchToEmu(heightIn);
    return `<w:p><w:r><w:drawing><wp:inline distT="0" distB="0" distL="0" distR="0" xmlns:wp="http://schemas.openxmlformats.org/officeDocument/2006/wordprocessingDrawing">`
      +`<wp:extent cx="${w}" cy="${h}"/>`
      +`<wp:docPr id="${docPrId}" name="Photo${docPrId}"/>`
      +`<a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">`
      +`<a:graphicData uri="http://schemas.openxmlformats.org/officeDocument/2006/relationships/picture">`
      +`<pic:pic xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture">`
      +`<pic:nvPicPr><pic:cNvPr id="0" name="photo"/><pic:cNvPicPr/></pic:nvPicPr>`
      +`<pic:blipFill><a:blip r:embed="${rid}" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"/><a:stretch><a:fillRect/></a:stretch></pic:blipFill>`
      +`<pic:spPr><a:xfrm><a:off x="0" y="0"/><a:ext cx="${w}" cy="${h}"/></a:xfrm><a:prstGeom prst="rect"><a:avLst/></a:prstGeom></pic:spPr>`
      +`</pic:pic></a:graphicData></a:graphic></wp:inline></w:drawing></w:r></w:p>`;
  }

  async function readImageFile(file){
    const dataUrl = await new Promise((resolve,reject)=>{
      const reader = new FileReader();
      reader.onload = ()=>resolve(reader.result);
      reader.onerror = ()=>reject(new Error('读取失败：'+file.name));
      reader.readAsDataURL(file);
    });
    const img = new Image();
    img.decoding = 'async';
    img.src = dataUrl;
    await img.decode().catch(()=>new Promise((resolve,reject)=>{
      img.onload = ()=>resolve();
      img.onerror = ()=>reject(new Error('无法解析图片：'+file.name));
    }));
    return img;
  }

  async function buildPhotoPages(files){
    if(!files.length) return [];
    const pages=[];
    for(let i=0;i<files.length;i+=2){
      const batch = files.slice(i,i+2);
      const images=[];
      for(const file of batch){
        try{
          const img = await readImageFile(file);
          images.push(img);
        }catch(err){
          console.error(err);
          alert(err.message+'（已跳过）');
        }
      }
      if(!images.length) continue;
      const width=2350;
      const cellH=1120;
      const gap=90;
      const margin=100;
      const height=margin*2 + images.length*cellH + Math.max(0,images.length-1)*gap;
      const canvas=document.createElement('canvas');
      canvas.width=width;
      canvas.height=height;
      const ctx=canvas.getContext('2d');
      ctx.fillStyle='#f8f9fb';
      ctx.fillRect(0,0,width,height);
      images.forEach((img,idx)=>{
        const top=margin + idx*(cellH+gap);
        ctx.fillStyle='#ffffff';
        ctx.fillRect(margin,top,width-margin*2,cellH);
        const maxW=width-margin*2-40;
        const maxH=cellH-40;
        const scale=Math.min(maxW/img.width,maxH/img.height,1);
        const drawW=img.width*scale;
        const drawH=img.height*scale;
        const dx=margin + (width-margin*2-drawW)/2;
        const dy=top + (cellH-drawH)/2;
        ctx.drawImage(img,dx,dy,drawW,drawH);
      });
      const base64=canvas.toDataURL('image/jpeg',0.9).split(',')[1];
      const widthIn=6.6;
      const heightIn=widthIn * (canvas.height/canvas.width);
      pages.push({ base64, widthIn, heightIn });
    }
    return pages;
  }

  function injectPhotoPages(zip,pages){
    if(!pages.length) return;
    ensureImageContentTypes(zip);
    const relPath='word/_rels/document.xml.rels';
    let rels=zip.file(relPath).asText();
    let docXml=zip.file('word/document.xml').asText();
    let block='';
    let docPr=800;
    pages.forEach((page,idx)=>{
      const result=addImageRelationship(zip,rels,page.base64);
      rels=result.rels;
      block+=buildDrawingXml(result.rid,page.widthIn,page.heightIn,docPr++);
      if(idx<pages.length-1){ block+='<w:p><w:r><w:br w:type="page"/></w:r></w:p>'; }
    });
    zip.file(relPath,rels);
    const tokenPara=new RegExp(`<w:p[^>]*>[\\s\\S]*?${escapeRegExp(PHOTO_TOKEN)}[\\s\\S]*?<\\/w:p>`);
    if(tokenPara.test(docXml)) docXml=docXml.replace(tokenPara,block);
    else docXml=docXml.replace(/<\/w:body>\s*<\/w:document>/,block+'</w:body></w:document>');
    zip.file('word/document.xml',docXml);
  }

  function downloadBlob(blob,name){
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a');
    a.href=url;
    a.download=name;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{URL.revokeObjectURL(url);a.remove();},1200);
  }

  async function generate(){
    try{
      const customer=document.getElementById('customer').value.trim();
      const industry=document.getElementById('industry').value.trim();
      const address=document.getElementById('address').value.trim();
      if(!customer){ alert('请填写客户名称'); return; }
      if(!industry){ alert('请填写行业分类'); return; }
      if(!address){ alert('请填写经营地址'); return; }
      let buffer=tplBuffer;
      if(!buffer){
        const file=tplInput && tplInput.files[0];
        if(!file){ alert('请导入模板文件'); return; }
        buffer=await file.arrayBuffer();
      }
      await ensurePizZip();
      const zip=new PizZip(buffer);
      const docPath='word/document.xml';
      let xml=zip.file(docPath).asText();
      const replacement={ '客户名称':customer,'行业分类':industry,'经营地址':address };
      const replaced=replacePlaceholdersXML(xml,replacement);
      const missing=PLACEHOLDERS.filter((k)=>replaced.stats[k]===0);
      if(missing.length){ throw new Error('模板缺少占位符：'+missing.join(',')); }
      setStatus('占位符命中：'+PLACEHOLDERS.map((k)=>k+replaced.stats[k]).join('，'));
      xml=replaced.xml;
      const needPhotos=selectedPhotos.length>0;
      if(needPhotos){ xml=ensurePhotoBlock(xml); }
      zip.file(docPath,xml);
      if(needPhotos){
        setStatus('正在处理照片…');
        const pages=await buildPhotoPages(selectedPhotos);
        if(!pages.length){ alert('未能读取任何照片，将生成无照片版本'); }
        else{ injectPhotoPages(zip,pages); setStatus('照片已排版：共 '+pages.length+' 页'); }
      }
      const blob=zip.generate({ type:'blob' });
      const fileName=sanitizeFileName(customer)+'新开户尽职调查表.docx';
      downloadBlob(blob,fileName);
      setStatus('✅ 已生成 '+fileName);
    }catch(err){
      console.error(err);
      setStatus('❌ 生成失败');
      alert('生成失败：'+err.message);
    }
  }

  document.getElementById('btnGen').addEventListener('click', generate);
  </script>
</body>
</html>
